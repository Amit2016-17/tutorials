
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Build a data source plugin</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="build-a-data-source-plugin"
                  title="Build a data source plugin"
                  environment="web"
                  feedback-link="https://github.com/grafana/grafana">
    
      <google-codelab-step label="Overview" duration="1">
        <p>Grafana has support for a wide range of data sources, like Prometheus, MySQL, or even Datadog. This means that it&#39;s very likely that you can already visualize metrics from the systems you&#39;ve already set up. In some cases though, you might already have an in-house metrics solution that you&#39;d like to add to your Grafana dashboards. Luckily, Grafana supports data source plugins, which lets you build a custom integration for your specific source of data.</p>
<p>In this codelab, you&#39;ll learn how to build a plugin to integrate with a custom data source.</p>
<h2 is-upgraded>What you&#39;ll need</h2>
<ul>
<li>Grafana version 6.4+</li>
<li>NodeJS</li>
<li>yarn</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Create a new plugin" duration="1">
        <p>Tooling for modern web development can be tricky to wrap your head around. While you certainly could write you own webpack configuration, for this guide, I&#39;m going to use grafana-toolkit.</p>
<p><a href="https://github.com/grafana/grafana/tree/master/packages/grafana-toolkit" target="_blank">grafana-toolkit</a> is a CLI application that aims to simplify Grafana plugin development, so that you can focus on code, and the toolkit takes care of building and testing it for us.</p>
<ul>
<li>Create a data source plugin from template, using the <code>plugin:create</code> command:<pre><code>npx grafana-toolkit plugin:create codelab2
</code></pre>
</li>
<li>Download necessary dependencies:<pre><code>yarn install
</code></pre>
</li>
<li>Build the plugin:<pre><code>yarn dev
</code></pre>
</li>
<li>Start Grafana to verify your plugin loads correctly.</li>
<li>To add the data source, navigate to <strong>Configuration</strong> -&gt; <strong>Data Sources</strong>, and click <strong>Add data source</strong>.</li>
<li>Type &#34;codelab2&#34;, and select your data source.</li>
<li>Click <strong>Save &amp; Test</strong>.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Add a config editor" duration="2">
        <p>For most data sources, you probably want to give your users the ability to configure things like hostname or authentication method. You can accomplish this by adding an <em>config editor</em>.</p>
<ul>
<li>In <code>types.ts</code>, update <code>MyDataSourceOptions</code> to contain a optional field named <code>path</code>:</li>
</ul>
<pre><code>export interface MyDataSourceOptions extends DataSourceJsonData {
  path?: string;
}
</code></pre>
<ul>
<li>In <code>ConfigEditor.tsx</code>, update the <code>render</code> function to return a <code>FormField</code> for our path option:</li>
</ul>
<pre><code>return (
  &lt;div className=&#34;gf-form-group&#34;&gt;
    &lt;div className=&#34;gf-form&#34;&gt;
      &lt;FormField label=&#34;Path&#34; labelWidth={6} onChange={this.onPathChange} value={jsonData.path || &#39;&#39;} placeholder=&#34;sample.csv&#34; /    &gt;
    &lt;/div&gt;
  &lt;/div&gt;
);
</code></pre>
<ul>
<li>Change the <code>onChange</code> function to update the path option with the value from the <code>FormField</code>.</li>
</ul>
<pre><code>onPathChange = (event: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
  const { onOptionsChange, options } = this.props;
  const jsonData = {
    ...options.jsonData,
    path: event.target.value,
  };
  onOptionsChange({ ...options, jsonData });
};
</code></pre>
<aside class="special"><p>Note: You might have noticed that we added the path to an object called <code>jsonData</code>. This object is automatically persisted for you, and will be made available to your data source implementation as well.</p>
</aside>
<ul>
<li>Build your assets with <code>yarn dev</code>.</li>
<li>Navigate to Configuration -&gt; Data Sources, and select your data source. The settings should now allow you to configure the path.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Add a query editor" duration="3">
        <p>Most likely you want your users to be able to select the data they&#39;re interested in. For MySQL and PostgreSQL this would be SQL queries, while Prometheus has its own query language, called PromQL. Let&#39;s add query support for our plugin, using a custom <em>query editor</em>.</p>
<ul>
<li>In <code>types.ts</code>, update <code>MyQuery</code> to contain a optional field named <code>values</code>:</li>
</ul>
<pre><code>export interface MyQuery extends DataQuery {
  values?: string;
}
</code></pre>
<pre><code>export const defaultQuery: Partial&lt;MyQuery&gt; = {
  values: &#39;value&#39;,
};
</code></pre>
<ul>
<li>In <code>QueryEditor.tsx</code>, update the <code>render</code> function to return a <code>FormField</code> for our query string:</li>
</ul>
<pre><code>render() {
  const query = defaults(this.props.query, defaultQuery);
  const { values } = query;

  return (
    &lt;div className=&#34;gf-form&#34;&gt;
      &lt;FormField label=&#34;Values&#34; value={values || &#39;&#39;} onChange={this.onValuesChange} /&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<ul>
<li>Update <code>DataSource.ts</code> to return a data frame with the values from the query editor.</li>
</ul>
<pre><code>query(options: DataQueryRequest&lt;MyQuery&gt;): Promise&lt;DataQueryResponse&gt; {
  const { range } = options;
  const from = range.from.valueOf();
  const to = range.to.valueOf();

  const data = options.targets.map(target =&gt; {
    const query = defaults(target, defaultQuery);

    const values = query.values.split(&#39;,&#39;).map(value =&gt; parseFloat(value));

    // Generate timestamps for every value.
    const timestamps = values.map((value, index) =&gt; {
      return from + (index / (values.length - 1)) * (to - from);
    });

    return new MutableDataFrame({
      refId: query.refId,
      fields: [
        { name: &#39;Time&#39;, values: timestamps, type: FieldType.time }, 
        { name: &#39;Value&#39;, values: values, type: FieldType.number },
      ],
    });
  });

  return Promise.resolve({ data });
}
</code></pre>
<ul>
<li>Build your assets with <code>yarn dev</code>.</li>
<li>Create a new dashboard.</li>
<li>Add a graph panel.</li>
<li>In the query editor, try adding a sequence of numbers, separated by commas.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Error handling" duration="4">
        <p>Use <code>throw</code> to display a friendly error message in the top-left corner of the panel whenever a data source error occurred:</p>
<pre><code>async query(options: DataQueryRequest&lt;MyQuery&gt;): Promise&lt;DataQueryResponse&gt; {
  throw { message: &#39;Malformed query&#39; };
}
</code></pre>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>

</body>
</html>
